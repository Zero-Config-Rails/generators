# Generated by Cursor AI with some minimal refactoring

namespace :rails_new do
  desc "Parse rails new --help output and generate configurations"
  task parse_options: :environment do
    require "open3"

    # Get the help output
    stdout, stderr, status = Open3.capture3("rails new --help")

    if status.success?
      parse_and_generate_configurations(stdout)
    else
      puts "Error running 'rails new --help': #{stderr}"
    end
  end

  private

  def parse_and_generate_configurations(help_output)
    configurations = []

    # Split the output into lines and process each option
    lines = help_output.lines.map(&:strip)

    # Find the options section
    options_start = lines.find_index { |line| line == "Options:" }
    options_end = lines.find_index { |line| line == "Runtime options:" }

    if options_start && options_end
      options_lines = lines[options_start + 1...options_end]
      configurations = parse_options_section(options_lines)
    end

    # Generate the configuration file
    generate_configuration_file(configurations)
  end

  def parse_options_section(lines)
    configurations = []
    current_option = nil
    current_description = []

    lines.each do |line|
      next if line.empty?

      # Check if this is a new option line (contains -- or -)
      if line.match?(/^\s*[-\[].*--/)
        # Save previous option if exists
        if current_option
          configurations << build_configuration(
            current_option,
            current_description.join(" ")
          )
        end

        # Extract option name and description from this line
        option_name, description = extract_option_and_description(line)
        current_option = option_name
        current_description = [description].compact
      elsif current_option && line.present? && !line.start_with?("Default:") &&
            !line.start_with?("Possible values:")
        # Continue description for current option
        current_description << line
      end
    end

    # Don't forget the last option
    if current_option
      configurations << build_configuration(
        current_option,
        current_description.join(" ")
      )
    end

    configurations.compact
  end

  def extract_option_and_description(line)
    # Handle different formats:
    # [--skip-namespace]                                            # Skip namespace
    # -r,            [--ruby=PATH]                                 # Path to the Ruby binary
    # -m,            [--template=TEMPLATE]                         # Path to some application template

    # Extract the option part
    option_match = line.match(/\[--([^\]]+)\]/)
    return nil, nil unless option_match

    option_name = option_match[1]

    # Handle cases like --ruby=PATH -> ruby
    option_name = option_name.split("=").first if option_name.include?("=")

    # Extract description (everything after #)
    description_match = line.match(/#\s*(.+)/)
    description = description_match ? description_match[1].strip : ""

    [option_name, description]
  end

  def build_configuration(option_name, description)
    return nil unless option_name

    # Determine the field type based on the option
    field_type = determine_field_type(option_name, description)
    default_value = extract_default_value(description) unless option_name ==
      "ruby"
    options = extract_options(option_name, description) # Pass option_name here

    {
      configuration_key: option_name,
      description: clean_description(description),
      is_required: false,
      fieldable_name: field_type,
      fieldable: build_fieldable(field_type, options, default_value),
      default_value: default_value
    }
  end

  def is_required_configuration?(option_name)
    # Only application_name is truly required
    option_name == "application_name"
  end

  def should_ignore_configuration?(option_name)
    # These configurations should be ignored/not included
    ignored_configurations = %w[name]

    ignored_configurations.include?(option_name)
  end

  def determine_field_type(option_name, description)
    # Determine field type based on option name and description
    if option_name.include?("skip-") || option_name.include?("no-") ||
         option_name.include?("dev") || option_name.include?("edge") ||
         option_name.include?("main") || option_name.include?("api") ||
         option_name.include?("minimal") || option_name.include?("devcontainer")
      "boolean_field"
    elsif description.include?("Possible values:") ||
          %w[database javascript css].include?(option_name)
      "dropdown_field"
    elsif option_name.include?("=") || description.include?("Path to") ||
          description.include?("Name of") ||
          %w[template ruby rc].include?(option_name)
      "text_field"
    else
      "boolean_field" # Default to boolean for flags
    end
  end

  def extract_default_value(description)
    if description.include?("Default:")
      default_match = description.match(/Default:\s*([^\s,]+)/)
      default_match ? default_match[1] : nil
    else
      nil
    end
  end

  def extract_options(option_name, description)
    if description.include?("Possible values:")
      values_match = description.match(/Possible values:\s*(.+)/)

      return unless values_match

      values = values_match[1].split(",").map(&:strip)

      values.map { |v| [v, v.titleize.humanize] }
    end
  end

  def clean_description(description)
    # Remove default and possible values from description
    description
      .gsub(/Default:\s*[^\s,]+/, "")
      .gsub(/Possible values:\s*[^#]+/, "")
      .strip
      .gsub(/\s+/, " ")
  end

  def build_fieldable(field_type, options, default_value)
    case field_type
    when "boolean_field"
      {
        type: "boolean_field",
        default_value:
          (
            if default_value == "true" || default_value == "false"
              default_value == "true"
            else
              false
            end
          )
      }
    when "dropdown_field"
      { type: field_type, options:, default_value: }
    else
      { type: "text_field", default_value: }
    end
  end

  def generate_configuration_file(configurations)
    # Filter out ignored configurations
    filtered_configurations =
      configurations.reject do |config|
        should_ignore_configuration?(config[:configuration_key])
      end
    required_configurations =
      filtered_configurations
        .select do |config|
          required_configuration_keys.include?(config[:configuration_key])
        end
        .sort_by do |config|
          required_configuration_keys.index(config[:configuration_key])
        end
    optional_configurations =
      filtered_configurations.reject do |config|
        required_configuration_keys.include?(config[:configuration_key])
      end

    # Create the configuration file content
    content = <<~RUBY
      # Auto-generated by Cursor AI from `rails new --help` output using `rake rails_new:parse_options`
      # Generated on: #{Time.current}

      module RailsGenerators::AutoGeneratedConfigurationsHelper
        ConfigurationStruct =
          Struct.new(
            :configuration_key,
            :label,
            :description,
            :is_required,
            :fieldable_name,
            :options,
            :fieldable,
            :should_hide_configuration_name,
            :default_value
          )
        FieldStruct = Struct.new(:type, :options, :default_value, keyword_init: true)

        def rails_app_generator_configurations
          [
            ConfigurationStruct.new(
              configuration_key: "application_name",
              description: "The name of your application",
              is_required: true,
              fieldable_name: "text_field",
              fieldable: FieldStruct.new(type: "text_field"),
              should_hide_configuration_name: true
            ),
            #{required_configurations.map { |config| format_configuration(config) }.join(",\n            ")}
          ]
        end

        def optional_rails_app_generator_configurations
          [
            #{optional_configurations.map { |config| format_configuration(config) }.join(",\n            ")}
          ]
        end
      end
    RUBY

    # Write to file
    file_path =
      Rails.root.join(
        "app",
        "helpers",
        "rails_generators",
        "auto_generated_configurations_helper.rb"
      )
    File.write(file_path, content)

    puts "Generated configuration file: #{file_path}"
    puts "Total configurations: #{filtered_configurations.length}"
    puts "\nConfiguration types:"
    filtered_configurations
      .group_by { |c| c[:fieldable_name] }
      .each { |type, configs| puts "  #{type}: #{configs.length}" }

    puts "\nRequired configurations:"
    filtered_configurations
      .select { |c| c[:is_required] }
      .each { |config| puts "  - #{config[:configuration_key]}" }

    puts "\nIgnored configurations:"
    configurations
      .select do |config|
        should_ignore_configuration?(config[:configuration_key])
      end
      .each { |config| puts "  - #{config[:configuration_key]}" }

    puts "\nSample configurations:"
    filtered_configurations
      .first(5)
      .each do |config|
        puts "  - #{config[:configuration_key]}: #{config[:description][0..50]}..."
      end

    # Run linting on generated file
    puts "\nRunning RuboCop linting on generated file..."
    system("bin/rubocop #{file_path} --autocorrect")
  end

  def required_configuration_keys
    %w[application_name template database javascript css api]
  end

  def format_configuration(config)
    fieldable_str =
      case config[:fieldable_name]
      when "boolean_field"
        "FieldStruct.new(type: \"boolean_field\", default_value: #{config[:fieldable][:default_value]})"
      when "dropdown_field"
        options_str =
          config[:fieldable][:options]
            .map { |opt| "[\"#{opt[0]}\", \"#{opt[1]}\"]" }
            .join(", ")
        "FieldStruct.new(type: \"dropdown_field\", options: [#{options_str}], default_value: \"#{config[:fieldable][:default_value]}\")"
      else
        "FieldStruct.new(type: \"text_field\", default_value: \"#{config[:fieldable][:default_value]}\")"
      end

    "ConfigurationStruct.new(
        configuration_key: \"#{config[:configuration_key]}\",
        description: \"#{config[:description]}\",
        is_required: #{config[:is_required]},
        fieldable_name: \"#{config[:fieldable_name]}\",
        fieldable: #{fieldable_str},
        should_hide_configuration_name: false,
        default_value: \"#{config[:default_value]}\"
      )"
  end
end
